apply from: project.file('metadata.gradle')

final ANDROID_SDK_PATH = {
    final localProperties = new Properties()
    try {
        localProperties.load(new FileInputStream("${project.rootProject.projectDir}/local.properties"))
    } catch (IOException e) { /* ignore errors */
    }
    def androidSdkPath = localProperties['sdk.dir'] ?: System.getenv('ANDROID_HOME')
    if (!androidSdkPath) {
        throw new RuntimeException("Missing local.properties")
    }
    androidSdkPath
}()
final ANDROID_SUPPORT_REPOSITORY = "${ANDROID_SDK_PATH}/extras/android/m2repository"

ext {
    SUPPORT_LIBRARY_VERSION = '25.1.0'
    ANDROID_JAR = fileTree(dir: "${ANDROID_SDK_PATH}/platforms/android-25/", include: 'android.jar')

    versionFile = project.file("VERSION")
    versionName = versionFile.readLines()[0].trim()
    metadata.version = versionName
}

buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:2.2.3'
        classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'
        classpath 'com.novoda:bintray-release:0.4.0' // https://github.com/novoda/bintray-release
        classpath 'me.tatarka.retrolambda.projectlombok:lombok.ast:0.2.3.a2'
    }

    // it conflicts with retrolambda
    configurations.classpath.exclude group: 'com.android.tools.external.lombok'
}

allprojects {
    repositories {
        maven {
            url ANDROID_SUPPORT_REPOSITORY
        }

        jcenter()
    }

    gradle.projectsEvaluated {
        if (project.name == "example") {
            return
        }

        tasks.withType(JavaCompile) {
            options.compilerArgs << "-Xlint:all" << "-Xlint:-processing"
        }
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}

def updateReadme(oldVersion, newVersion) {
    def template = file('README.md').text
    def result = template.replaceAll(java.util.regex.Pattern.quote(oldVersion), newVersion)
    file("README.md").withWriter { it << result }
}

task bumpMajor << {
    def oldVersion = versionName
    def versionParts = versionName.split(/\./)
    versionParts[0] = (versionParts[0] as int) + 1
    def newVersion = "${versionParts[0]}.0.0"
    versionFile.write(newVersion + "\n")
    updateReadme(oldVersion, newVersion)
    tasks.version.execute()
}

task bumpMinor << {
    def oldVersion = versionName
    def versionParts = versionName.split(/\./)
    versionParts[1] = (versionParts[1] as int) + 1
    def newVersion = "${versionParts[0]}.${versionParts[1]}.0"
    versionFile.write(newVersion + "\n")
    updateReadme(oldVersion, newVersion)
    tasks.version.execute()
}

task bumpPatch << {
    def oldVersion = versionName
    def versionParts = versionName.split(/\./)
    versionParts[2] = (versionParts[2].split(/\D/)[0] as int) + 1
    def newVersion = "${versionParts[0]}.${versionParts[1]}.${versionParts[2]}"
    versionFile.write(newVersion + "\n")
    updateReadme(oldVersion, newVersion)
    tasks.version.execute()
}

task version << {
    println "v" + versionFile.readLines()[0]
}

String shell(String command) {
    def proc = ["sh", "-c", "cd ${project.rootDir} ; ${command}"].execute()
    if (proc.waitFor() != 0) {
        throw new RuntimeException("Failed to run: ${command}\n${proc.err.text}")
    } else {
        def err = proc.err.text
        if (err) {
            System.err.println(err)
        }
    }
    return proc.in.text;
}

task releng << {
    def tag = "v" + versionName
    println "Release engineering for ${tag}"

    def changes = shell "git status -s"
    if (changes.trim()) {
        throw new RuntimeException("There are changes not commited yet.\n${changes}")
    }

    println "> git tag ${tag}"
    shell "git tag ${tag}"
    println "> git push origin ${tag}"
    shell "git push origin ${tag}"
    shell "git push origin master"
}

class TimingsListener implements TaskExecutionListener, BuildListener {
    private Clock clock
    private timings = []

    @Override
    void beforeExecute(Task task) {
        clock = new org.gradle.util.Clock()
    }

    @Override
    void afterExecute(Task task, TaskState taskState) {
        def ms = clock.timeInMs
        timings.add([ms, task.path])
    }

    @Override
    void buildFinished(BuildResult result) {
        def timingsOverThreshold = timings.grep { timing -> timing[0] > 1000 }
        if (!timingsOverThreshold.empty) {
            println "Task timings:"
            for (timing in timingsOverThreshold) {
                printf "%7sms  %s\n", timing
            }
        }
    }

    @Override
    void buildStarted(Gradle gradle) {}

    @Override
    void projectsEvaluated(Gradle gradle) {}

    @Override
    void projectsLoaded(Gradle gradle) {}

    @Override
    void settingsEvaluated(Settings settings) {}
}

gradle.addListener new TimingsListener()
